<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme="auto">
  <head>
    <meta charset="UTF-8" />
    <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png" />
    <link rel="icon" href="/img/favicon.png" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no"
    />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />

    <meta
      http-equiv="Content-Security-Policy"
      content="upgrade-insecure-requests"
    />

    <meta name="theme-color" content="#2f4154" />
    <meta name="author" content="Egg Targaryen" />
    <meta name="keywords" content="" />

    <meta
      name="description"
      content="Adversarial Substructured Representation Learning for Mobile User Profiling


 Pengyang Wang，Yanjie Fu，Hui Xiong，Xiaolin Li
 Missouri Univ. of Sci. and Tech.
 Rutgers University
 Nanjing University"
    />
    <meta property="og:type" content="article" />
    <meta
      property="og:title"
      content="Adversarial Substructured Representation Learning for Mobile User Profiling 阅读笔记"
    />
    <meta
      property="og:url"
      content="http://example.com/2022/06/13/Adversarial-Substructured-Representation-Learning-for-Mobile-User-Profiling-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html"
    />
    <meta property="og:site_name" content="EggTargaryen的个人博客" />
    <meta
      property="og:description"
      content="Adversarial Substructured Representation Learning for Mobile User Profiling


 Pengyang Wang，Yanjie Fu，Hui Xiong，Xiaolin Li
 Missouri Univ. of Sci. and Tech.
 Rutgers University
 Nanjing University"
    />
    <meta property="og:locale" content="zh_CN" />
    <meta
      property="og:image"
      content="https://s2.loli.net/2022/06/13/6jvfdPrEkZG7pHS.png"
    />
    <meta
      property="article:published_time"
      content="2022-06-13T13:10:14.000Z"
    />
    <meta property="article:modified_time" content="2022-06-13T13:11:42.281Z" />
    <meta property="article:author" content="Egg Targaryen" />
    <meta property="article:tag" content="论文笔记" />
    <meta property="article:tag" content="信息系统" />
    <meta property="article:tag" content="数据挖掘" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:image"
      content="https://s2.loli.net/2022/06/13/6jvfdPrEkZG7pHS.png"
    />

    <title>
      Adversarial Substructured Representation Learning for Mobile User
      Profiling 阅读笔记 - EggTargaryen的个人博客
    </title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"
    />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css"
    />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css"
    />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css"
    />

    <!-- 主题依赖的图标库，不要自行修改 -->

    <link
      rel="stylesheet"
      href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"
    />

    <link
      rel="stylesheet"
      href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"
    />

    <link rel="stylesheet" href="/css/main.css" />

    <!-- 自定义样式保持在最底部 -->

    <script id="fluid-configs">
      var Fluid = window.Fluid || {};
      var CONFIG = {
        hostname: 'example.com',
        root: '/',
        version: '1.8.14',
        typing: { enable: true, typeSpeed: 70, cursorChar: '_', loop: false },
        anchorjs: {
          enable: true,
          element: 'h1,h2,h3,h4,h5,h6',
          placement: 'right',
          visible: 'hover',
          icon: '',
        },
        progressbar: {
          enable: true,
          height_px: 3,
          color: '#29d',
          options: { showSpinner: false, trickleSpeed: 100 },
        },
        copy_btn: true,
        image_zoom: { enable: true, img_url_replace: ['', ''] },
        toc: {
          enable: true,
          headingSelector: 'h1,h2,h3,h4,h5,h6',
          collapseDepth: 0,
        },
        lazyload: {
          enable: true,
          loading_img: '/img/loading.gif',
          onlypost: false,
          offset_factor: 2,
        },
        web_analytics: {
          enable: false,
          baidu: null,
          google: null,
          gtag: null,
          tencent: { sid: null, cid: null },
          woyaola: null,
          cnzz: null,
          leancloud: {
            app_id: null,
            app_key: null,
            server_url: null,
            path: 'window.location.pathname',
            ignore_local: false,
          },
        },
        search_path: '/local-search.xml',
      };
    </script>
    <script src="/js/utils.js"></script>
    <script src="/js/color-schema.js"></script>
    <meta name="generator" content="Hexo 6.2.0" />
  </head>

  <body>
    <header style="height: 70vh">
      <nav
        id="navbar"
        class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"
      >
        <div class="container">
          <a class="navbar-brand" href="/">
            <strong>EggTargaryen的个人博客</strong>
          </a>

          <button
            id="navbar-toggler-btn"
            class="navbar-toggler"
            type="button"
            data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent"
            aria-expanded="false"
            aria-label="Toggle navigation"
          >
            <div class="animated-icon">
              <span></span><span></span><span></span>
            </div>
          </button>

          <!-- Collapsible content -->
          <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav ml-auto text-center">
              <li class="nav-item">
                <a class="nav-link" href="/">
                  <i class="iconfont icon-home-fill"></i>
                  首页
                </a>
              </li>

              <li class="nav-item">
                <a class="nav-link" href="/archives/">
                  <i class="iconfont icon-archive-fill"></i>
                  归档
                </a>
              </li>

              <li class="nav-item">
                <a class="nav-link" href="/categories/">
                  <i class="iconfont icon-category-fill"></i>
                  分类
                </a>
              </li>

              <li class="nav-item">
                <a class="nav-link" href="/tags/">
                  <i class="iconfont icon-tags-fill"></i>
                  标签
                </a>
              </li>

              <li class="nav-item">
                <a class="nav-link" href="/about/">
                  <i class="iconfont icon-user-fill"></i>
                  关于
                </a>
              </li>

              <li class="nav-item" id="search-btn">
                <a
                  class="nav-link"
                  target="_self"
                  href="javascript:;"
                  data-toggle="modal"
                  data-target="#modalSearch"
                  aria-label="Search"
                >
                  &nbsp;<i class="iconfont icon-search"></i>&nbsp;
                </a>
              </li>

              <li class="nav-item" id="color-toggle-btn">
                <a
                  class="nav-link"
                  target="_self"
                  href="javascript:;"
                  aria-label="Color Toggle"
                  >&nbsp;<i
                    class="iconfont icon-dark"
                    id="color-toggle-icon"
                  ></i
                  >&nbsp;</a
                >
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <div
        class="banner"
        id="banner"
        parallax="true"
        style="
          background: url('/img/default.png') no-repeat center center;
          background-size: cover;
        "
      >
        <div class="full-bg-img">
          <div
            class="mask flex-center"
            style="background-color: rgba(0, 0, 0, 0.3)"
          >
            <div class="page-header text-center fade-in-up">
              <span
                class="h2"
                id="subtitle"
                title="Adversarial Substructured Representation Learning for Mobile User Profiling 阅读笔记"
              >
              </span>

              <div class="mt-3">
                <span class="post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2022-06-13 21:10" pubdate>
                    2022年6月13日 晚上
                  </time>
                </span>
              </div>

              <div class="mt-1">
                <span class="post-meta mr-2">
                  <i class="iconfont icon-chart"></i>
                  10k 字
                </span>

                <span class="post-meta mr-2">
                  <i class="iconfont icon-clock-fill"></i>

                  84 分钟
                </span>

                <!-- 不蒜子统计文章PV -->
                <span id="busuanzi_container_page_pv" style="display: none">
                  <i class="iconfont icon-eye" aria-hidden="true"></i>
                  <span id="busuanzi_value_page_pv"></span> 次
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </header>

    <main>
      <div class="container-fluid nopadding-x">
        <div class="row nomargin-x">
          <div class="d-none d-lg-block col-lg-2"></div>
          <div class="col-lg-8 nopadding-x-md">
            <div class="container nopadding-x-md" id="board-ctn">
              <div class="py-5" id="board">
                <article class="post-content mx-auto">
                  <!-- SEO header -->
                  <h1 style="display: none">
                    Adversarial Substructured Representation Learning for Mobile
                    User Profiling 阅读笔记
                  </h1>

                  <p class="note note-info">本文最后更新于：几秒前</p>

                  <div class="markdown-body">
                    <h1
                      id="adversarial-substructured-representation-learning-for-mobile-user-profiling"
                    >
                      Adversarial Substructured Representation Learning for
                      Mobile User Profiling
                    </h1>
                    <blockquote>
                      <ul>
                        <li>Pengyang Wang，Yanjie Fu，Hui Xiong，Xiaolin Li</li>
                        <li>Missouri Univ. of Sci. and Tech.</li>
                        <li>Rutgers University</li>
                        <li>Nanjing University</li>
                        <li>
                          <a
                            target="_blank"
                            rel="noopener"
                            href="https://dl.acm.org/doi/abs/10.1145/3292500.3330869"
                            >KDD 2019</a
                          >
                        </li>
                      </ul>
                    </blockquote>
                    <h2 id="背景知识">背景知识</h2>
                    <ul>
                      <li>移动用户分析是对用户特定移动活动的特征总结。</li>
                      <li>
                        移动用户特征分析是指从移动活动中提取用户的兴趣和行为模式，如购物和通勤。
                      </li>
                      <li>
                        之前的研究可分为：
                        <ol type="1">
                          <li>
                            明确的特征提取。通过明确定义并从移动行为数据（如人口统计学、网站点击、移动购买、应用内行为）中提取的内容特征来分析用户。这样的分析方法高度依赖于对全面的用户相关信息的收集。
                          </li>
                          <li>
                            隐性轮廓学习，包括协作方法、潜在因素模型、网络嵌入和深度学习。
                            <ul>
                              <li>
                                特别是，协作方法假设同一群体的用户行为相似，因此，共享相似的分析。这类方法受到目标用户的同伴信息稀少的影响。
                              </li>
                              <li>
                                潜在因素模型，如矩阵/张量因子化或基于主题建模的变体，被开发用来将用户资料建模为潜伏因子或分类分布表示。这类方法通过大参数空间的优化来学习用户特征，因此，很容易过度拟合。它高度需要领域知识启发的模型正则化。
                              </li>
                            </ul>
                          </li>
                        </ol>
                      </li>
                      <li>
                        人类的活动，如购物、上学、工作、吃饭、旅行、娱乐，都是有空间、时间和社会结构的。我们如何确定一个数据结构来更好地描述一个移动用户的活动？传统的方法提取基于内容的特征向量，并不足以解决这个问题。
                      </li>
                    </ul>
                    <h2 id="本文方法">本文方法</h2>
                    <h3 id="方法描述">方法描述</h3>
                    <p>
                      我们知道，一个网页的点击率在很大程度上取决于网页内容和网页结构。同样，如果我们把一个移动用户看作是一个网页，那么用户的活动就可以看作是网页内容，而用户的活动转换模式就可以看作是网页结构。图被广泛用于描述结构性和关系性的知识。一个移动用户的资料确实是一个固有的相互联系的活动组成，并且可以很容易地被建模为一个图。
                    </p>
                    <p>
                      我们建议构建一个用户活动图来描述每个移动用户，其中顶点是活动类型（即POI类别），边是活动（POI类别）之间的转换频率。通过这种方式，我们将移动用户分析重新表述为从用户活动图中学习用户的深度表征问题。
                    </p>
                    <p>
                      在研究了许多用户活动图之后，我们发现了另一种重要的结构信息，我们称之为子结构。子结构指的是具有特定拓扑结构的子图。这种子结构确实表明了移动用户独特的个性化活动模式，并暗示了用户的社会属性和偏好。例如，年轻人喜欢在工作综合体、餐馆和电影院之间中转，而企业家喜欢在商业广场之间中转。
                    </p>
                    <p>
                      在本文中，我们重点关注用户活动图的两个子结构：高频顶点和环。
                    </p>
                    <blockquote>
                      <p>例子：</p>
                      <figure>
                        <img
                          src="https://s2.loli.net/2022/06/13/MrQeo6DTFmuApO2.png"
                          srcset="/img/loading.gif"
                          lazyload
                          alt="图1"
                        />
                        <figcaption aria-hidden="true">图1</figcaption>
                      </figure>
                      <p>
                        图1显示了两个用户活动图的例子，它们是从用户的移动签到事件集中提取的<code
                          >&#123;&lt;事件ID，用户ID，日期，POI类别，经度，纬度&gt;
                          &#125;</code
                        >。红色环显示了用户在工作日中经常在不同的POI类别之间转换，青色的独立顶点是该用户在工作期间经常访问的。不同的用户从他们的活动图中显示出不同的子结构。
                      </p>
                      <p>
                        显然，图1(a)显示了一个有小孩的教师的活动图，其中用户在家里、办公室和幼儿园之间转换，并在工作期间经常访问与大学有关的POI类别；而图1(b)显示了一个金融专业人士的活动图，其中用户在家里、商业广场和餐馆之间转换，并在工作后经常访问健身房和咖啡馆。
                      </p>
                    </blockquote>
                    <p>
                      如何将子结构模式整合到用户活动图的表示学习中？我们非常需要一个统一的学习框架来对整个图和子结构信息共同建模。
                    </p>
                    <p>
                      现有方法的一些问题：一个直观的方法是使用Embedding技术，例如自动编码器，来学习整个图的表示。然后，子结构信息被表述为优化目标的正则化项。然而，如图1所示，不同用户的活动子结构具有不同的拓扑结构（高频顶点，环）；这些用户的活动子结构动态地分布在图的不同位置。损失函数中的正则化项无法解决训练中的这些挑战（不同的拓扑结构和分布）。
                    </p>
                    <p>
                      解决方法：<strong>生成式对抗网络的出现为解决这一问题提供了巨大的潜力。我们建议将子结构的整合转化为对抗性子结构学习范式。这个范式包括一个自动编码器，用于保留整个图的结构；一个子结构检测器，用于检测图中的子结构；一个对抗训练器，用于通过对抗性攻击纳入子结构的正则化。</strong>所提出的对抗性子结构学习范式似乎可以从战略上解决这个问题。学习范式可以战略性地解决这些挑战。但是，我们后来发现，如果我们使用传统的子图检测算法（例如，DFS）来作为检测器，<strong>这些检测算法通常是不可微的，因此无法对梯度就行反向传播</strong>。为了解决这个问题，我们建议预先训练一个卷积神经网络来捕捉子结构的模式，以接近传统的不可微的子结构算法。
                    </p>
                    <p>
                      在本文中，我们开发了一个用于移动用户分析的对抗性子结构学习框架。
                    </p>
                    <p>贡献如下：</p>
                    <ol type="1">
                      <li>
                        我们创建用户活动图来描述移动用户的特征、模式和偏好。
                      </li>
                      <li>
                        我们将移动用户分析重新表述为学习用户活动图的深度表示的问题。
                      </li>
                      <li>
                        我们确定了另一个结构信息：用户活动图中的子结构，并开发了一个对抗性的子结构学习范式，包括一个自动编码器、一个检测器和一个对抗性训练器，以保留整个图和子结构信息。
                      </li>
                      <li>
                        我们预先训练了一个卷积神经网络（CNN）来近似于传统的子图检测算法，以解决不可微的问题。
                      </li>
                      <li>
                        我们将用户分析的结果应用于下一个活动类型的预测，并提出了大量的实验，以证明所提出的方法在现实世界中的增强性能。所提出的方法在真实世界的移动签到数据中的增强性能。
                      </li>
                    </ol>
                    <h3 id="前置知识点">前置知识点</h3>
                    <ol type="1">
                      <li>
                        <p>
                          定义1：<strong>用户活动图/User Activity Graph</strong
                          >。一个移动用户的活动被表示为一个用户活动图，其中顶点是活动类型（即POI类别），边是POI类别之间的转换频率。图1显示用户活动图可以描述用户活动的行为结构信息。
                        </p>
                      </li>
                      <li>
                        <p>
                          定义2：<strong
                            >整图结构/Structure of the entire graph</strong
                          >。给定一个用户活动图<span class="math inline"
                            >\(G=(V,E)\)</span
                          >，其中V是顶点集，E是边集，整图结构被定义为整个图的全局拓扑表示。整图结构保留了顶点和边之间的关系。对于移动用户，整图结构可以捕获所有POI类别的一般偏好模式。
                        </p>
                      </li>
                      <li>
                        <p>
                          定义3：<strong
                            >子图结构（子结构）/Structure of the
                            subgraph</strong
                          >。其被定义为子图的拓扑表示，能以用户活动的独特行为模式为特征。在本文中，我们重点关注两种类型的子结构。(1)
                          高频顶点，其累计访问频率高于预先定义的阈值；(2)
                          环。具体来说，用户活动图中的高频顶点代表对特定类型活动的个性化偏好；用户活动图中的环代表对闭环连续活动模式的个性化偏好。高频顶点和环都可以暗示用户在日常生活中的独特活动模式。
                        </p>
                      </li>
                      <li>
                        <p>
                          定义4：<strong>问题陈述/Problem Statement</strong
                          >。在本文中，我们研究了利用移动活动数据学习用户特征的问题。我们的目标是自动学习一个分析向量来代表一个用户的活动模式。我们从移动活动数据，即POI签到数据中提取用户活动图，以代表移动用户的活动模式。因此，我们把这个问题表述为一个学习用户活动图的深度表征的任务。虽然用户活动图展示了一个用户的整体活动情况，但用户的独特活动模式通常由活动图的各种子结构所暗示。因此，这项任务是一个共同的目标，即在用户活动图中同时保留整体活动模式和在表征学习中保存用户的子结构模式。
                        </p>
                        <p>
                          从形式上看，给定一组用户活动图，我们的目标是找到一个映射函数<span
                            class="math inline"
                            >\(f:x\rightarrow z\)</span
                          >，该函数将用户活动图x作为输入，并输出用户的矢量表示z，同时遵守整图结构和子结构的保存约束。
                        </p>
                      </li>
                    </ol>
                    <h3 id="框架概览">框架概览</h3>
                    <figure>
                      <img
                        src="https://s2.loli.net/2022/06/13/6jvfdPrEkZG7pHS.png"
                        srcset="/img/loading.gif"
                        lazyload
                        alt="图2"
                      />
                      <figcaption aria-hidden="true">图2</figcaption>
                    </figure>
                    <p>图2显示了我们提出的框架的概况，其中包括以下基本任务：</p>
                    <ul>
                      <li><p>构建用户活动图来表示移动用户的概况；</p></li>
                      <li>
                        <p>
                          开发一个对抗性的子结构学习框架，从用户活动图中学习用户表征；
                        </p>
                      </li>
                      <li>
                        <p>
                          在下一个活动类型预测的应用中评估学到的用户表征。在第一个任务中，给定用户的移动签到序列，我们为每个用户构建一个用户活动图。在第二个任务中，我们开发了对抗性子结构学习框架，其共同目标是：
                        </p>
                        <ul>
                          <li><p>对用户活动图的整图结构进行建模；</p></li>
                          <li><p>构建一个可微分的子结构检测器；</p></li>
                          <li>
                            <p>利用对抗性训练将子结构正则化纳入表征学习。</p>
                          </li>
                        </ul>
                        <p>
                          在最后一项任务中，我们应用我们提出的方法对移动用户进行剖析，以进行下一个活动类型的预测。
                        </p>
                      </li>
                    </ul>
                    <h3 id="对抗性子结构学习">对抗性子结构学习</h3>
                    <figure>
                      <img
                        src="https://s2.loli.net/2022/06/13/2l46mup9MvxW1Aq.png"
                        srcset="/img/loading.gif"
                        lazyload
                        alt="图3"
                      />
                      <figcaption aria-hidden="true">图3</figcaption>
                    </figure>
                    <h4 id="模型直觉">模型直觉</h4>
                    <ol type="1">
                      <li>
                        直觉1：<strong>整图结构保留</strong>。活动图的整图结构代表了用户活动之间的相互作用。这种互动可以是强链接、弱链接或无链接。因此，我们应该保留全局行为模式。
                      </li>
                      <li>
                        直觉2：<strong>子结构保留</strong>。活动图中有一些独特的子结构，如高频活动和活动过渡环，它们可以独特地描述用户的概况。我们应该保留子结构的行为模式。
                      </li>
                      <li>
                        直觉3：<strong>整图结构与子结构的整合</strong>。直观地说，我们可以通过网络Embedding对整个结构进行建模，并通过优化正则化捕获子结构。然而，不同的用户在他们的子结构中可能表现出不同的活动类型、拓扑结构和空间分布。我们需要一个新的学习范式来统一整图结构和子结构。
                      </li>
                      <li>
                        直觉4：<strong>可微的子结构检测器</strong>。传统的子图检测算法是不可微的。如果这些检测算法被整合到深度学习框架中，就很难应用梯度下降法进行优化。因此，我们需要一个可微分的子结构检测器来接近非可微的检测算法。
                      </li>
                    </ol>
                    <h4 id="总体思路">总体思路</h4>
                    <p>
                      图3显示了我们提出的对抗性子结构学习框架，包括一个深度自动编码器、一个近似的子结构检测器、一个判别器和一个对抗性训练器。自动编码器是为了保留整图结构并推导出图的表示。我们使用传统的子图检测算法来检测子结构标签，然后使用这些标签来预训练一个CNN来接近传统的子图检测算法。鉴别器是对原始图的子结构（真实的子结构集）和重建图的子结构（生成的子结构集）进行分类。对抗训练器通过强制自编码器特别注意保留重建图中的子结构来整合子结构意识，以混淆鉴别器。
                    </p>
                    <h4 id="保留整图结构">保留整图结构</h4>
                    <p>
                      我们利用深度自动编码器，在表征学习中保留用户的全局行为结构。具体来说，该自动编码器包括一个编码步骤和一个解码步骤。编码步骤将用户活动图作为输入，并输出一个用户特征向量。解码步骤使用用户特征向量来重构用户活动图。用户特征向量通过最小化重建损失来捕捉全局行为结构。
                    </p>
                    <p>
                      形式上，对于给定的第<span class="math inline">\(i\)</span
                      >个图，我们通过将每个顶点的邻居连接信息链接成单一向量来扁平化该图，用<span
                        class="math inline"
                        >\(x_i\)</span
                      >来表示，这确实捕捉到了图的全局结构。令<span
                        class="math inline"
                        >\(y^1,y^2,...,y^o\)</span
                      >分别为编码步骤中隐藏层<span class="math inline"
                        >\(1,2,...,o\)</span
                      >的图的潜在特征表示。用户活动图的Embedding表示为一个<span
                        class="math inline"
                        >\(d\)</span
                      >维向量，标记为<span class="math inline"
                        >\(z_i\in \mathbb{R}^d\)</span
                      >。因此，编码步骤表示为：
                      <span class="math display"
                        >\[ \begin{cases} y_i^1=\sigma (W^1x_i+b^1)\nonumber\\
                        y_i^k=\sigma (W^ky_i^{k-1}+b^k),\forall
                        k\in\{2,3,...,o\}\nonumber\\ z_i=\sigma
                        (W^{o+1}y_i^o+b^{o+1})\nonumber \end{cases} \]</span
                      >
                      解码器将Embedding表示<span class="math inline"
                        >\(z_i\)</span
                      >作为输入，输出一个重建图，标记为<span class="math inline"
                        >\(\hat{x}_i\)</span
                      >。每个隐藏层的潜在特征向量为<span class="math inline"
                        >\(\hat{y}_i^1,\hat{y}_i^2,...,\hat{y}_i^o\)</span
                      >。解码过程表示为：
                      <span class="math display"
                        >\[ \begin{cases} \hat{y}_i^o=\sigma
                        (\hat{W}^{o+1}z_i+\hat{b}^{o+1})\nonumber\\
                        \hat{y}_i^{k-1}=\sigma
                        (\hat{W}^k\hat{y}_i^k+\hat{b}^k),\forall
                        k\in\{2,3,...,o\}\nonumber\\ \hat{x}_i=\sigma
                        (\hat{W}^1\hat{y}_i^1+\hat{b}^1)\nonumber \end{cases}
                        \]</span
                      >
                      其中，<span class="math inline">\(W,b\)</span
                      >分别为可学习的权重矩阵和bias。
                    </p>
                    <p>
                      最小化原图<span class="math inline">\(x\)</span
                      >和重建图<span class="math inline">\(\hat{x}\)</span
                      >之间的损失，损失函数为：
                      <span class="math display"
                        >\[ \begin{align}
                        {\cal{L}}_{AE}&amp;=\frac{1}{2}\sum_{i=1}^m||(x_i-\hat{x}_i)||_2^2
                        \end{align} \]</span
                      >
                    </p>
                    <h4 id="近似子结构检测器">近似子结构检测器</h4>
                    <p>
                      传统的子结构检测算法，例如，基于DFS的子图检测，是不可微的。神经网络的梯度不能通过反向传播来传递。因此，我们建议使用预先训练好的卷积神经网络（CNN）来近似传统的子结构检测器。
                    </p>
                    <p>
                      形式上，令<span class="math inline">\(F_{detr}\)</span
                      >为传统的子结构检测器，<span class="math inline"
                        >\(F_{cnn}\)</span
                      >为CNN子结构检测器。近似过程有以下两个步骤：
                    </p>
                    <ol type="1">
                      <li>
                        <strong>生成子结构（label）</strong>。使用活动图<span
                          class="math inline"
                          >\(x\)</span
                        >作为输入通过<span class="math inline"
                          >\(F_{detr}\)</span
                        >生成对应的真实子结构<span class="math inline"
                          >\(s_{real}\)</span
                        >作为标注。
                      </li>
                      <li>
                        <strong
                          >训练<span class="math inline">\(F_{cnn}\)</span
                          >近似<span class="math inline"
                            >\(F_{detr}\)</span
                          ></strong
                        >。<span class="math inline">\(F_{cnn}\)</span
                        >结构包含两组<code
                          >&#123;Conv, Relu, MaxPooling&#125;</code
                        >，其中卷积核为5，池化核为2。令<span class="math inline"
                          >\(\hat{s}\)</span
                        >为<span class="math inline">\(F_{cnn}\)</span
                        >的输出，训练目标是最小化损失：<span class="math inline"
                          >\({\cal{L}}_{cnn}=\frac{1}{2}\sum_{i=1}^m||(s_{real}-\hat{s})||_2^2\)</span
                        >。
                      </li>
                    </ol>
                    <p>
                      最终，我们得到了预先训练好的<span class="math inline"
                        >\(F_{cnn}\)</span
                      >作为一个可微分的、近似的子结构检测器。
                    </p>
                    <h4 id="通过对抗训练整合子结构信息">
                      通过对抗训练整合子结构信息
                    </h4>
                    <p>
                      图3(b)显示，我们开发了一种对抗性学习策略，包括一个生成器、一个鉴别器和一个对抗性训练器，以整合子结构信息。
                    </p>
                    <ul>
                      <li>
                        <p>
                          <strong>生成器</strong
                          >：图3(b)显示，生成器将一个深度自动编码器和一个基于预训练的CNN检测器联系起来。具体来说，我们将预先训练好的CNN连接到解码器的最后一层，这样CNN就将解码器输出的重构图<span
                            class="math inline"
                            >\(\hat{x}\)</span
                          >作为输入。CNN从重建的图中检测并输出一个子结构，用<span
                            class="math inline"
                            >\(\hat{s}\)</span
                          >表示。让G表示生成器，那么映射过程可以表示为：<span
                            class="math inline"
                            >\(\hat{s}_i=G(x_i)\)</span
                          >。
                        </p>
                      </li>
                      <li>
                        <p>
                          <strong>判别器</strong
                          >：图3(b)显示，判别器为一个多层感知机<span
                            class="math inline"
                            >\(D(s;\theta_d)\)</span
                          >，其中<span class="math inline">\(\theta_d\)</span
                          >为其参数，<span class="math inline">\(D(s)\)</span
                          >输出一个概率，表明子结构<span class="math inline"
                            >\(s\)</span
                          >来自真实的子结构集<span class="math inline"
                            >\(s_{real}\)</span
                          >而不是生成的子结构集<span class="math inline"
                            >\(\hat{s}\)</span
                          >的可能性。
                        </p>
                      </li>
                      <li>
                        <p>
                          <strong>对抗训练策略</strong
                          >：D的训练是为了最大限度地提高对真实子结构和由G产生的重建子结构的分类精度。G的训练是为了最小化D对由G产生的重建子结构集的分类精度。
                        </p>
                        <p>
                          形式上，让<span class="math inline"
                            >\(p_{real}(s)\)</span
                          >表示真实子结构集<span class="math inline"
                            >\(s_{real}\)</span
                          >的分布，<span class="math inline">\(p_x(x)\)</span
                          >表示原图集<span class="math inline">\(x\)</span
                          >的分布，对抗训练的minimax函数如下：
                          <span class="math display"
                            >\[ \begin{align} \begin{matrix} min\\ G
                            \end{matrix} \, \begin{matrix} max\\ D \end{matrix}
                            \,V(D,G)&amp;=\mathbb{E}_{s\sim p_{real}(s)}[\log
                            D(s)]+\mathbb{E}_{x\sim p_x(x)}[\log (1-D(G(x)))]
                            \end{align} \]</span
                          >
                          特别的，判别器分类准确度为：
                          <span class="math display"
                            >\[ \begin{align}
                            {\cal{L}}_D&amp;=\frac{1}{m}\sum_{i=1}^m[\log
                            D(s_i)+\log (1-D(G(x_i)))] \end{align} \]</span
                          >
                          生成器损失为：
                          <span class="math display"
                            >\[ \begin{align}
                            {\cal{L}}_G&amp;=\frac{1}{m}\sum_{i=1}^m\log(1-D(G(x_i)))
                            \end{align} \]</span
                          >
                          目标就是最大化损失<span class="math inline"
                            >\({\cal{L}}_D\)</span
                          >和最小化损失<span class="math inline"
                            >\({\cal{L}}_G\)</span
                          >。
                        </p>
                      </li>
                    </ul>
                    <h4 id="解决优化问题">解决优化问题</h4>
                    <p>
                      该模型的损失函数包括。(i) 重建损失最小化（公式1）；(ii)
                      鉴别器精度最大化（公式3）；以及(iii)
                      发生器损失最小化（公式4）。其目的是使总体损失<span
                        class="math inline"
                        >\(\cal{L}\)</span
                      >最小化，具体如下：
                      <span class="math display"
                        >\[ \begin{align}
                        {\cal{L}}=-\lambda_D{\cal{L}}_D+\lambda_G{\cal{L}}_G+\lambda_{AE}{\cal{L}}_{AE}
                        \end{align} \]</span
                      >
                      在<strong>训练阶段</strong>，采用随机梯度下降法来优化，具体来说，先通过下式更新自动编码器：
                      <span class="math display"
                        >\[ \triangledown_{\theta_{AE}}||(x_i-\hat{x}_i)||_2^2
                        \]</span
                      >
                      然后在保持预训练检测器<span class="math inline"
                        >\(F_{detr}\)</span
                      >参数不变的前提下更新生成器，生成器参数<span
                        class="math inline"
                        >\(\theta_g\)</span
                      >与自动编码器参数<span class="math inline"
                        >\(\theta_{AE}\)</span
                      >相同，所以通过下式更新生成器：
                      <span class="math display"
                        >\[
                        \triangledown_{\theta_{AE}}\frac{1}{m}\sum_{i=1}^m\log(1-D(G(x^i)))
                        \]</span
                      >
                      然后更新判别器：
                      <span class="math display"
                        >\[
                        -\triangledown_{\theta_{AE}}\frac{1}{m}\sum_{i=1}^m[\log
                        D(s^i)+\log(1-D(G(x^i)))] \]</span
                      >
                      在<strong>测试阶段</strong>，图3(c)显示，我们使用子结构感知编码器来学习用户活动图的表示。
                    </p>
                    <h4 id="讨论">讨论</h4>
                    <p>
                      在最近的研究中，有一些与保留结构信息的表示学习有关的工作。例如，Wang等人提出在表征学习中对一阶接近性（即仅由边连接的顶点之间的局部成对相似性）和二阶接近性（即顶点的邻域结构的相似性）进行建模。Yu等人提出通过共同考虑保全位置和全局重建的约束，用对抗性正则化自动编码器来捕获网络结构。这些工作与我们的论文的区别在于，我们的工作旨在将子结构（即子图的结构）整合到整图结构（即整个图的结构）中，而之前的这些工作是对局部结构（即邻居的结构）和全局结构的联合建模。
                    </p>
                    <h3 id="预测下一个活动类型用户分析">
                      预测下一个活动类型用户分析
                    </h3>
                    <p>
                      作为一种应用，我们使用所提出的方法对用户活动图进行剖析，并推断出下一个活动类型，以评估其性能。具体来说，我们首先将一个POI类别视为一种活动类型。然后，对下一个活动类型的偏好由POI类别的访问概率分布来表示，标记为<span
                        class="math inline"
                        >\(P^i_{visit}=\{P^{i,1}_{visit},P^{i,2}_{visit},...,P^{i,k}_{visit}\}\)</span
                      >，这实际上是第二天每个POI类别的归一化访问频率。其中，<span
                        class="math inline"
                        >\(P^{i,k}_{visit}\)</span
                      >表示用户<span class="math inline">\(u_i\)</span
                      >访问第<span class="math inline">\(k\)</span
                      >个POI类别的概率。
                    </p>
                    <p>
                      定义：<strong>下一步要做什么问题</strong>。考虑到用户的历史POI签到记录，我们的目标是通过推断用户在下一天将访问的POI类别的概率来预测用户的下一个活动类型。
                    </p>
                    <p>
                      具体来说，对每个用户<span class="math inline"
                        >\(u_i\)</span
                      >，首先构建用户活动图<span class="math inline"
                        >\(G_i\)</span
                      >，其中一个顶点是一个POI类别的概率，而一条边的权重是访问从一个POI类别到另一个POI类别的频率。然后我们利用我们的方法来学习用户<span
                        class="math inline"
                        >\(u_i\)</span
                      >的表征<span class="math inline">\(z_i\)</span
                      >。之后，将<span class="math inline">\(z_i\)</span
                      >作为输入，训练一个全连接神经网络<span class="math inline"
                        >\(NN\)</span
                      >，以预测每个用户对下一个活动类型的偏好：<span
                        class="math inline"
                        >\(NN:z_i\rightarrow P^i_{visit}\)</span
                      >。最后，我们根据访问概率对POI类别进行排序，生成一个候选列表<span
                        class="math inline"
                        >\(R_i\)</span
                      >。
                    </p>
                    <h2 id="实验结果">实验结果</h2>
                    <h3 id="数据描述">数据描述</h3>
                    <p>
                      表1显示了我们来自两个城市的两个签到数据集的统计数据：纽约和东京。每个数据集包括用户ID，场地ID，场地类别ID，场地类别名称，纬度，经度，和时间。
                    </p>
                    <table>
                      <thead>
                        <tr class="header">
                          <th style="text-align: center">城市</th>
                          <th style="text-align: center"># Check-ins</th>
                          <th style="text-align: center"># POI类别</th>
                          <th style="text-align: center">Time Period</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr class="odd">
                          <td style="text-align: center">纽约</td>
                          <td style="text-align: center">227428</td>
                          <td style="text-align: center">251</td>
                          <td style="text-align: center">
                            12 April 2012 to 16 February 2013
                          </td>
                        </tr>
                        <tr class="even">
                          <td style="text-align: center">东京</td>
                          <td style="text-align: center">573703</td>
                          <td style="text-align: center">247</td>
                          <td style="text-align: center">
                            12 April 2012 to 16 February 2013
                          </td>
                        </tr>
                      </tbody>
                    </table>
                    <h3 id="评估指标">评估指标</h3>
                    <ol type="1">
                      <li>
                        <p>
                          <span class="math inline">\(Precision@N\)</span
                          >：是指预测用户历史上进行过的下一个预先存在的活动类型的精度。令<span
                            class="math inline"
                            >\(\hat{R}_i\)</span
                          >表示根据相应的预测访问概率降序排列的Top-K个预测POI类别列表，<span
                            class="math inline"
                            >\(R_i\)</span
                          >表示已访问的POI类别列表，<span class="math inline"
                            >\(U\)</span
                          >表示用户集，则<span class="math inline"
                            >\(Precision@N\)</span
                          >计算公式如下：
                          <span class="math display"
                            >\[ Precision@N=\frac{1}{|N|}\sum_{u_i\in
                            U}\frac{|\hat{R}^N_i\cap R_i|}{|R_i|} \]</span
                          >
                        </p>
                      </li>
                      <li>
                        <p>
                          <span class="math inline">\(Precision^{new}@N\)</span
                          >：是预测用户历史上从未执行过的下一个新活动类型的精度。令<span
                            class="math inline"
                            >\(R^{new}_i\)</span
                          >表示用户<span class="math inline">\(u_i\)</span
                          >在训练集中没有访问过但是在测试集中被访问过的POI类别列表。那么，<span
                            class="math inline"
                            >\(Precision^{new}@N\)</span
                          >计算公式如下：
                          <span class="math display"
                            >\[ Precision^{new}@N=\frac{1}{|U|}\sum_{u_i\in
                            U}\frac{|\hat{R}^N_i\cap R^{new}_i|}{|R^{new}_i|}
                            \]</span
                          >
                        </p>
                      </li>
                    </ol>
                    <h3 id="模型性能">模型性能</h3>
                    <figure>
                      <img
                        src="https://s2.loli.net/2022/06/13/ScELqUmWeHk97TO.png"
                        srcset="/img/loading.gif"
                        lazyload
                        alt="图4"
                      />
                      <figcaption aria-hidden="true">图4</figcaption>
                    </figure>
                    <p>
                      我们在<span class="math inline">\(Precision@N\)</span
                      >和<span class="math inline">\(Precision^{new}@N\)</span
                      >方面将我们的方法与Baseline方法进行比较。总的来说，图4显示我们的模型在纽约和东京数据集上都取得了最佳性能。在<strong>预测下一个预先存在的活动类型的任务</strong>中，我们观察到当K变大时，我们的方法的准确性比Baseline方法要好得多。在<strong>预测下一个新活动类型的任务</strong>中，我们的方法在发现用户从未访问过的新POI类别方面仍然优于Baseline方法。结果验证了子结构对于用户分析是必不可少的。具体来说，用户活动图的子结构暗示了一些特定的用户活动模式。例如，环子结构可以以特定
                      POI
                      类别的活动转换模式为特征，而Node结构可以以用户对多个独立POI类别的偏好为特征。我们提出的框架通过对抗训练有效地考虑了子结构和整图结构。然而，Auto-Encoder、DeepWalk、CNN
                      和 LINE
                      无法学习具有子结构意识的表示，从而降低了它们的预测性能。
                    </p>
                    <h3 id="鲁棒性检验">鲁棒性检验</h3>
                    <p>
                      为了进行鲁棒性检验，我们将我们的方法应用于不同的数据子组，以检查我们的表现的差异性。具体来说，我们将数据集平均分成五个时间段，包括（1）2012年4月12日-2012年6月12日，（2）2012年6月13日-2012年8月13日，（3）2012年8月14日-2012年10月14日，（4）2012年8月15日-2012年10月15日，和（5）2012年10月16日-2013年2月16日。我们将每个时间段的最后一天的活动作为预测目标来进行评估。我们对纽约和东京数据集的预测性能进行了<span
                        class="math inline"
                        >\(Precision@N\)</span
                      >和<span class="math inline">\(Precision^{new}@N\)</span
                      >的评估。图5和图6显示，我们的方法可以达到较小的方差，并且相对稳定，特别是当K较小时。
                    </p>
                    <figure>
                      <img
                        src="https://s2.loli.net/2022/06/13/DhWo6zklKLJ5rjy.png"
                        srcset="/img/loading.gif"
                        lazyload
                        alt="图5与图6"
                      />
                      <figcaption aria-hidden="true">图5与图6</figcaption>
                    </figure>
                    <h3 id="子结构保留的研究">子结构保留的研究</h3>
                    <figure>
                      <img
                        src="https://s2.loli.net/2022/06/13/iNOzoM5LTjwrkyC.png"
                        srcset="/img/loading.gif"
                        lazyload
                        alt="图7"
                      />
                      <figcaption aria-hidden="true">图7</figcaption>
                    </figure>
                    <p>
                      我们引入了两种类型的子结构：独立顶点和环。因此，我们研究这两种不同的子结构类型如何影响我们的方法在使用分析上的表现。具体来说，我们表示（1）StructRL-Node：我们框架的一个变体，只考虑离散顶点的子结构；（2）StructRL-环：我们框架的一个变体，只考虑环的子结构；（3）StructRL：我们提出的方法，考虑两者。
                    </p>
                    <p>
                      图7显示，StructRL-环的性能总是略微胜过StructRL-Node；换句话说，环的子结构比离散顶点的子结构更有效，可以描述用户的活动模式。环的子结构显示了用户的环活动转换模式，而独立顶点的子结构则显示了用户高度和密集偏好的一些独立POI类别。因此，环的子结构可以描述POI类别之间的相关性，以暗示用户的特定生活方式模式，这比独立顶点的子结构更能提供信息。
                    </p>
                    <h3 id="训练损失的研究">训练损失的研究</h3>
                    <figure>
                      <img
                        src="https://s2.loli.net/2022/06/13/YodzmtUcASIKl9O.png"
                        srcset="/img/loading.gif"
                        lazyload
                        alt="图8"
                      />
                      <figcaption aria-hidden="true">图8</figcaption>
                    </figure>
                    <p>
                      图8显示了我们的方法在不同子结构和不同数据集方面的训练损失。重建损失表明了保留图的全局结构模式的有效性。对抗性训练损失表明将子结构整合到整图结构的学习过程。我们可以看到，在同时进行对抗性训练时，重建损失会收敛。换句话说，将子结构信息整合到全局结构中，有助于训练损失的收敛。
                    </p>
                    <h2 id="结论">结论</h2>
                    <p>
                      我们研究自动移动用户分析的问题。我们将用户表示为活动图，并将用户分析问题重新表述为从用户活动图中学习表示的任务。在分析了众多用户活动图之后，我们发现保留图的整图结构和子结构至关重要。我们观察到，图中子结构的内容、拓扑和位置可以随不同用户动态变化。我们提出了一种对抗性子结构学习方法，在表示学习中联合建模整图结构和子结构（即暗示移动用户独特的个性化活动模式）。具体来说，我们首先采用自动编码通过最小化图重建损失来对整图结构进行建模。此外，我们预训练了一个CNN来逼近不可微分的子结构检测器，因此子结构检测器可以与自动编码配合使用。此外，我们通过将预训练的CNN附加到自动编码器的最后一层来设计生成器，以生成子结构。此外，我们通过对抗性训练整合子结构意识，联合最小化图重建损失和生成器损失并最大化鉴别器损失。我们还将我们的方法应用于预测下一个活动类型的应用。我们用纽约和东京的数据展示了密集的实验结果，以证明我们方法的有效性。
                    </p>
                  </div>
                  <hr />
                  <div>
                    <div class="post-metas mb-3">
                      <div class="post-meta mr-3">
                        <i class="iconfont icon-category"></i>

                        <a
                          class="hover-with-bg"
                          href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"
                          >论文笔记</a
                        >

                        <a
                          class="hover-with-bg"
                          href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/"
                          >信息系统</a
                        >

                        <a
                          class="hover-with-bg"
                          href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"
                          >数据挖掘</a
                        >
                      </div>

                      <div class="post-meta">
                        <i class="iconfont icon-tags"></i>

                        <a
                          class="hover-with-bg"
                          href="/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"
                          >论文笔记</a
                        >

                        <a
                          class="hover-with-bg"
                          href="/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/"
                          >信息系统</a
                        >

                        <a
                          class="hover-with-bg"
                          href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"
                          >数据挖掘</a
                        >
                      </div>
                    </div>

                    <p class="note note-warning">
                      本博客所有文章除特别声明外，均采用
                      <a
                        target="_blank"
                        href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh"
                        rel="nofollow noopener noopener"
                        >CC BY-SA 4.0 协议</a
                      >
                      ，转载请注明出处！
                    </p>

                    <div class="post-prevnext">
                      <article class="post-prev col-6"></article>
                      <article class="post-next col-6">
                        <a
                          href="/2022/05/28/RepMLPNet-Hierarchical-Vision-MLP-with-Re-parameterized-Locality-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"
                        >
                          <span class="hidden-mobile"
                            >RepMLPNet: Hierarchical Vision MLP with
                            Re-parameterized Locality 阅读笔记</span
                          >
                          <span class="visible-mobile">下一篇</span>
                          <i class="iconfont icon-arrowright"></i>
                        </a>
                      </article>
                    </div>
                  </div>
                </article>
              </div>
            </div>
          </div>

          <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
            <div id="toc">
              <p class="toc-header">
                <i class="iconfont icon-list"></i>&nbsp;目录
              </p>
              <div class="toc-body" id="toc-body"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Custom -->

      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>

      <div
        class="modal fade"
        id="modalSearch"
        tabindex="-1"
        role="dialog"
        aria-labelledby="ModalLabel"
        aria-hidden="true"
      >
        <div
          class="modal-dialog modal-dialog-scrollable modal-lg"
          role="document"
        >
          <div class="modal-content">
            <div class="modal-header text-center">
              <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
              <button
                type="button"
                id="local-search-close"
                class="close"
                data-dismiss="modal"
                aria-label="Close"
              >
                <span aria-hidden="true">&times;</span>
              </button>
            </div>
            <div class="modal-body mx-3">
              <div class="md-form mb-5">
                <input
                  type="text"
                  id="local-search-input"
                  class="form-control validate"
                />
                <label data-error="x" data-success="v" for="local-search-input"
                  >关键词</label
                >
              </div>
              <div class="list-group" id="local-search-result"></div>
            </div>
          </div>
        </div>
      </div>
    </main>

    <footer class="text-center mt-5 py-3">
      <div class="footer-content">
        <a href="https://hexo.io" target="_blank" rel="nofollow noopener"
          ><span>Hexo</span></a
        >
        <i class="iconfont icon-love"></i>
        <a
          href="https://github.com/fluid-dev/hexo-theme-fluid"
          target="_blank"
          rel="nofollow noopener"
          ><span>Fluid</span></a
        >
      </div>

      <div class="statistics">
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
          总访问量
          <span id="busuanzi_value_site_pv"></span>
          次
        </span>

        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
          总访客数
          <span id="busuanzi_value_site_uv"></span>
          人
        </span>
      </div>
    </footer>

    <!-- SCRIPTS -->

    <script src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css"
    />

    <script>
      NProgress.configure({ showSpinner: false, trickleSpeed: 100 });
      NProgress.start();
      window.addEventListener('load', function () {
        NProgress.done();
      });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js"></script>
    <script src="/js/events.js"></script>
    <script src="/js/plugins.js"></script>

    <!-- Plugins -->

    <script src="/js/local-search.js"></script>

    <script src="/js/img-lazyload.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js"></script>

    <script
      defer
      src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"
    ></script>

    <script
      defer
      src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"
    ></script>

    <script src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js"></script>
    <script>
      (function (window, document) {
        var typing = Fluid.plugins.typing;
        var title = document.getElementById('subtitle').title;

        typing(title);
      })(window, document);
    </script>

    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ['$', '$'],
            ['\\(', '\\)'],
          ],
        },
        loader: {
          load: ['ui/lazy'],
        },
        options: {
          renderActions: {
            findScript: [
              10,
              (doc) => {
                document
                  .querySelectorAll('script[type^="math/tex"]')
                  .forEach((node) => {
                    const display = !!node.type.match(/; *mode=display/);
                    const math = new doc.options.MathItem(
                      node.textContent,
                      doc.inputJax[0],
                      display
                    );
                    const text = document.createTextNode('');
                    node.parentNode.replaceChild(text, node);
                    math.start = { node: text, delim: '', n: 0 };
                    math.end = { node: text, delim: '', n: 0 };
                    doc.math.push(math);
                  });
              },
              '',
              false,
            ],
            insertedScript: [
              200,
              () => {
                document.querySelectorAll('mjx-container').forEach((node) => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              },
              '',
              false,
            ],
          },
        },
      };
    </script>

    <script
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
    ></script>

    <!-- 主题的启动项 保持在最底部 -->
    <script src="/js/boot.js"></script>
  </body>
</html>
